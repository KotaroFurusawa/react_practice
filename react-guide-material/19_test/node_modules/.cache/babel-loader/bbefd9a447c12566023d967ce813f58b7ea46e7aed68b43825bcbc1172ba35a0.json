{"ast":null,"code":"import { getWindow } from '../misc/getWindow.js';\nimport { readBlobText } from './Blob.js';\nimport { createDataTransfer, getBlobFromDataTransferItem } from './DataTransfer.js';\n\n// Clipboard is not available in jsdom\n// MDN lists string|Blob|Promise<Blob|string> as possible types in ClipboardItemData\n// lib.dom.d.ts lists only Promise<Blob|string>\n// https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem/ClipboardItem#syntax\nfunction createClipboardItem(window) {\n  for (var _len = arguments.length, blobs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    blobs[_key - 1] = arguments[_key];\n  }\n  const dataMap = Object.fromEntries(blobs.map(b => [typeof b === 'string' ? 'text/plain' : b.type, Promise.resolve(b)]));\n  // use real ClipboardItem if available\n  /* istanbul ignore if */\n  if (typeof window.ClipboardItem !== 'undefined') {\n    return new window.ClipboardItem(dataMap);\n  }\n  return new class ClipboardItem {\n    get types() {\n      return Array.from(Object.keys(this.data));\n    }\n    async getType(type) {\n      const value = await this.data[type];\n      if (!value) {\n        throw new Error(`${type} is not one of the available MIME types on this item.`);\n      }\n      return value instanceof window.Blob ? value : new window.Blob([value], {\n        type\n      });\n    }\n    constructor(d) {\n      this.data = d;\n    }\n  }(dataMap);\n}\nconst ClipboardStubControl = Symbol('Manage ClipboardSub');\nfunction createClipboardStub(window, control) {\n  return Object.assign(new class Clipboard extends window.EventTarget {\n    async read() {\n      return Array.from(this.items);\n    }\n    async readText() {\n      let text = '';\n      for (const item of this.items) {\n        const type = item.types.includes('text/plain') ? 'text/plain' : item.types.find(t => t.startsWith('text/'));\n        if (type) {\n          text += await item.getType(type).then(b => readBlobText(b, window.FileReader));\n        }\n      }\n      return text;\n    }\n    async write(data) {\n      this.items = data;\n    }\n    async writeText(text) {\n      this.items = [createClipboardItem(window, text)];\n    }\n    constructor() {\n      super(...arguments);\n      this.items = [];\n    }\n  }(), {\n    [ClipboardStubControl]: control\n  });\n}\nfunction isClipboardStub(clipboard) {\n  var ref;\n  return !!((ref = clipboard) === null || ref === void 0 ? void 0 : ref[ClipboardStubControl]);\n}\nfunction attachClipboardStubToView(window) {\n  if (isClipboardStub(window.navigator.clipboard)) {\n    return window.navigator.clipboard[ClipboardStubControl];\n  }\n  const realClipboard = Object.getOwnPropertyDescriptor(window.navigator, 'clipboard');\n  let stub;\n  const control = {\n    resetClipboardStub: () => {\n      stub = createClipboardStub(window, control);\n    },\n    detachClipboardStub: () => {\n      /* istanbul ignore if */if (realClipboard) {\n        Object.defineProperty(window.navigator, 'clipboard', realClipboard);\n      } else {\n        Object.defineProperty(window.navigator, 'clipboard', {\n          value: undefined,\n          configurable: true\n        });\n      }\n    }\n  };\n  stub = createClipboardStub(window, control);\n  Object.defineProperty(window.navigator, 'clipboard', {\n    get: () => stub,\n    configurable: true\n  });\n  return stub[ClipboardStubControl];\n}\nfunction resetClipboardStubOnView(window) {\n  if (isClipboardStub(window.navigator.clipboard)) {\n    window.navigator.clipboard[ClipboardStubControl].resetClipboardStub();\n  }\n}\nfunction detachClipboardStubFromView(window) {\n  if (isClipboardStub(window.navigator.clipboard)) {\n    window.navigator.clipboard[ClipboardStubControl].detachClipboardStub();\n  }\n}\nasync function readDataTransferFromClipboard(document) {\n  const window = document.defaultView;\n  const clipboard = window === null || window === void 0 ? void 0 : window.navigator.clipboard;\n  const items = clipboard && (await clipboard.read());\n  if (!items) {\n    throw new Error('The Clipboard API is unavailable.');\n  }\n  const dt = createDataTransfer(window);\n  for (const item of items) {\n    for (const type of item.types) {\n      dt.setData(type, await item.getType(type).then(b => readBlobText(b, window.FileReader)));\n    }\n  }\n  return dt;\n}\nasync function writeDataTransferToClipboard(document, clipboardData) {\n  const window = getWindow(document);\n  const clipboard = window.navigator.clipboard;\n  const items = [];\n  for (let i = 0; i < clipboardData.items.length; i++) {\n    const dtItem = clipboardData.items[i];\n    const blob = getBlobFromDataTransferItem(window, dtItem);\n    items.push(createClipboardItem(window, blob));\n  }\n  const written = clipboard && (await clipboard.write(items).then(() => true,\n  // Can happen with other implementations that e.g. require permissions\n  /* istanbul ignore next */\n  () => false));\n  if (!written) {\n    throw new Error('The Clipboard API is unavailable.');\n  }\n}\n/* istanbul ignore else */\nif (typeof globalThis.afterEach === 'function') {\n  globalThis.afterEach(() => resetClipboardStubOnView(globalThis.window));\n}\n/* istanbul ignore else */\nif (typeof globalThis.afterAll === 'function') {\n  globalThis.afterAll(() => detachClipboardStubFromView(globalThis.window));\n}\nexport { attachClipboardStubToView, createClipboardItem, detachClipboardStubFromView, readDataTransferFromClipboard, resetClipboardStubOnView, writeDataTransferToClipboard };","map":{"version":3,"names":["getWindow","readBlobText","createDataTransfer","getBlobFromDataTransferItem","createClipboardItem","window","blobs","dataMap","Object","fromEntries","map","b","type","Promise","resolve","ClipboardItem","types","Array","from","keys","data","getType","value","Error","Blob","constructor","d","ClipboardStubControl","Symbol","createClipboardStub","control","assign","Clipboard","EventTarget","read","items","readText","text","item","includes","find","t","startsWith","then","FileReader","write","writeText","isClipboardStub","clipboard","ref","attachClipboardStubToView","navigator","realClipboard","getOwnPropertyDescriptor","stub","resetClipboardStub","detachClipboardStub","defineProperty","undefined","configurable","get","resetClipboardStubOnView","detachClipboardStubFromView","readDataTransferFromClipboard","document","defaultView","dt","setData","writeDataTransferToClipboard","clipboardData","i","length","dtItem","blob","push","written","globalThis","afterEach","afterAll"],"sources":["/Users/furusawakoutarou/Desktop/programming/React/react-guide-material/19_test/node_modules/@testing-library/user-event/dist/esm/utils/dataTransfer/Clipboard.js"],"sourcesContent":["import { getWindow } from '../misc/getWindow.js';\nimport { readBlobText } from './Blob.js';\nimport { createDataTransfer, getBlobFromDataTransferItem } from './DataTransfer.js';\n\n// Clipboard is not available in jsdom\n// MDN lists string|Blob|Promise<Blob|string> as possible types in ClipboardItemData\n// lib.dom.d.ts lists only Promise<Blob|string>\n// https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem/ClipboardItem#syntax\nfunction createClipboardItem(window, ...blobs) {\n    const dataMap = Object.fromEntries(blobs.map((b)=>[\n            typeof b === 'string' ? 'text/plain' : b.type,\n            Promise.resolve(b), \n        ]));\n    // use real ClipboardItem if available\n    /* istanbul ignore if */ if (typeof window.ClipboardItem !== 'undefined') {\n        return new window.ClipboardItem(dataMap);\n    }\n    return new class ClipboardItem {\n        get types() {\n            return Array.from(Object.keys(this.data));\n        }\n        async getType(type) {\n            const value = await this.data[type];\n            if (!value) {\n                throw new Error(`${type} is not one of the available MIME types on this item.`);\n            }\n            return value instanceof window.Blob ? value : new window.Blob([\n                value\n            ], {\n                type\n            });\n        }\n        constructor(d){\n            this.data = d;\n        }\n    }(dataMap);\n}\nconst ClipboardStubControl = Symbol('Manage ClipboardSub');\nfunction createClipboardStub(window, control) {\n    return Object.assign(new class Clipboard extends window.EventTarget {\n        async read() {\n            return Array.from(this.items);\n        }\n        async readText() {\n            let text = '';\n            for (const item of this.items){\n                const type = item.types.includes('text/plain') ? 'text/plain' : item.types.find((t)=>t.startsWith('text/'));\n                if (type) {\n                    text += await item.getType(type).then((b)=>readBlobText(b, window.FileReader));\n                }\n            }\n            return text;\n        }\n        async write(data) {\n            this.items = data;\n        }\n        async writeText(text) {\n            this.items = [\n                createClipboardItem(window, text)\n            ];\n        }\n        constructor(...args){\n            super(...args);\n            this.items = [];\n        }\n    }(), {\n        [ClipboardStubControl]: control\n    });\n}\nfunction isClipboardStub(clipboard) {\n    var ref;\n    return !!((ref = clipboard) === null || ref === void 0 ? void 0 : ref[ClipboardStubControl]);\n}\nfunction attachClipboardStubToView(window) {\n    if (isClipboardStub(window.navigator.clipboard)) {\n        return window.navigator.clipboard[ClipboardStubControl];\n    }\n    const realClipboard = Object.getOwnPropertyDescriptor(window.navigator, 'clipboard');\n    let stub;\n    const control = {\n        resetClipboardStub: ()=>{\n            stub = createClipboardStub(window, control);\n        },\n        detachClipboardStub: ()=>{\n            /* istanbul ignore if */ if (realClipboard) {\n                Object.defineProperty(window.navigator, 'clipboard', realClipboard);\n            } else {\n                Object.defineProperty(window.navigator, 'clipboard', {\n                    value: undefined,\n                    configurable: true\n                });\n            }\n        }\n    };\n    stub = createClipboardStub(window, control);\n    Object.defineProperty(window.navigator, 'clipboard', {\n        get: ()=>stub,\n        configurable: true\n    });\n    return stub[ClipboardStubControl];\n}\nfunction resetClipboardStubOnView(window) {\n    if (isClipboardStub(window.navigator.clipboard)) {\n        window.navigator.clipboard[ClipboardStubControl].resetClipboardStub();\n    }\n}\nfunction detachClipboardStubFromView(window) {\n    if (isClipboardStub(window.navigator.clipboard)) {\n        window.navigator.clipboard[ClipboardStubControl].detachClipboardStub();\n    }\n}\nasync function readDataTransferFromClipboard(document) {\n    const window = document.defaultView;\n    const clipboard = window === null || window === void 0 ? void 0 : window.navigator.clipboard;\n    const items = clipboard && await clipboard.read();\n    if (!items) {\n        throw new Error('The Clipboard API is unavailable.');\n    }\n    const dt = createDataTransfer(window);\n    for (const item of items){\n        for (const type of item.types){\n            dt.setData(type, await item.getType(type).then((b)=>readBlobText(b, window.FileReader)));\n        }\n    }\n    return dt;\n}\nasync function writeDataTransferToClipboard(document, clipboardData) {\n    const window = getWindow(document);\n    const clipboard = window.navigator.clipboard;\n    const items = [];\n    for(let i = 0; i < clipboardData.items.length; i++){\n        const dtItem = clipboardData.items[i];\n        const blob = getBlobFromDataTransferItem(window, dtItem);\n        items.push(createClipboardItem(window, blob));\n    }\n    const written = clipboard && await clipboard.write(items).then(()=>true, // Can happen with other implementations that e.g. require permissions\n    /* istanbul ignore next */ ()=>false);\n    if (!written) {\n        throw new Error('The Clipboard API is unavailable.');\n    }\n}\n/* istanbul ignore else */ if (typeof globalThis.afterEach === 'function') {\n    globalThis.afterEach(()=>resetClipboardStubOnView(globalThis.window));\n}\n/* istanbul ignore else */ if (typeof globalThis.afterAll === 'function') {\n    globalThis.afterAll(()=>detachClipboardStubFromView(globalThis.window));\n}\n\nexport { attachClipboardStubToView, createClipboardItem, detachClipboardStubFromView, readDataTransferFromClipboard, resetClipboardStubOnView, writeDataTransferToClipboard };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}