{"ast":null,"code":"import '../utils/click/isClickableInput.js';\nimport '../utils/dataTransfer/Clipboard.js';\nimport '../utils/edit/isEditable.js';\nimport '../utils/edit/maxLength.js';\nimport '@testing-library/dom/dist/helpers.js';\nimport { readNextDescriptor } from '../utils/keyDef/readNextDescriptor.js';\nimport '../utils/misc/level.js';\nimport '../options.js';\n\n/**\n * Parse key defintions per `keyboardMap`\n *\n * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.\n * Everything else will be interpreted as a typed character - e.g. `a`.\n * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.\n * Keeping the key pressed can be written as `{key>}`.\n * When keeping the key pressed you can choose how long (how many keydown and keypress) the key is pressed `{key>3}`.\n * You can then release the key per `{key>3/}` or keep it pressed and continue with the next key.\n */\nfunction parseKeyDef(keyboardMap, text) {\n  const defs = [];\n  do {\n    const {\n      type,\n      descriptor,\n      consumedLength,\n      releasePrevious,\n      releaseSelf = true,\n      repeat\n    } = readNextDescriptor(text, 'keyboard');\n    var ref;\n    const keyDef = (ref = keyboardMap.find(def => {\n      if (type === '[') {\n        var ref;\n        return ((ref = def.code) === null || ref === void 0 ? void 0 : ref.toLowerCase()) === descriptor.toLowerCase();\n      } else if (type === '{') {\n        var ref1;\n        return ((ref1 = def.key) === null || ref1 === void 0 ? void 0 : ref1.toLowerCase()) === descriptor.toLowerCase();\n      }\n      return def.key === descriptor;\n    })) !== null && ref !== void 0 ? ref : {\n      key: 'Unknown',\n      code: 'Unknown',\n      [type === '[' ? 'code' : 'key']: descriptor\n    };\n    defs.push({\n      keyDef,\n      releasePrevious,\n      releaseSelf,\n      repeat\n    });\n    text = text.slice(consumedLength);\n  } while (text);\n  return defs;\n}\nexport { parseKeyDef };","map":{"version":3,"names":["readNextDescriptor","parseKeyDef","keyboardMap","text","defs","type","descriptor","consumedLength","releasePrevious","releaseSelf","repeat","ref","keyDef","find","def","code","toLowerCase","ref1","key","push","slice"],"sources":["/Users/furusawakoutarou/Desktop/programming/React/react-guide-material/19_test/node_modules/@testing-library/user-event/dist/esm/keyboard/parseKeyDef.js"],"sourcesContent":["import '../utils/click/isClickableInput.js';\nimport '../utils/dataTransfer/Clipboard.js';\nimport '../utils/edit/isEditable.js';\nimport '../utils/edit/maxLength.js';\nimport '@testing-library/dom/dist/helpers.js';\nimport { readNextDescriptor } from '../utils/keyDef/readNextDescriptor.js';\nimport '../utils/misc/level.js';\nimport '../options.js';\n\n/**\n * Parse key defintions per `keyboardMap`\n *\n * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.\n * Everything else will be interpreted as a typed character - e.g. `a`.\n * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.\n * Keeping the key pressed can be written as `{key>}`.\n * When keeping the key pressed you can choose how long (how many keydown and keypress) the key is pressed `{key>3}`.\n * You can then release the key per `{key>3/}` or keep it pressed and continue with the next key.\n */ function parseKeyDef(keyboardMap, text) {\n    const defs = [];\n    do {\n        const { type , descriptor , consumedLength , releasePrevious , releaseSelf =true , repeat ,  } = readNextDescriptor(text, 'keyboard');\n        var ref;\n        const keyDef = (ref = keyboardMap.find((def)=>{\n            if (type === '[') {\n                var ref;\n                return ((ref = def.code) === null || ref === void 0 ? void 0 : ref.toLowerCase()) === descriptor.toLowerCase();\n            } else if (type === '{') {\n                var ref1;\n                return ((ref1 = def.key) === null || ref1 === void 0 ? void 0 : ref1.toLowerCase()) === descriptor.toLowerCase();\n            }\n            return def.key === descriptor;\n        })) !== null && ref !== void 0 ? ref : {\n            key: 'Unknown',\n            code: 'Unknown',\n            [type === '[' ? 'code' : 'key']: descriptor\n        };\n        defs.push({\n            keyDef,\n            releasePrevious,\n            releaseSelf,\n            repeat\n        });\n        text = text.slice(consumedLength);\n    }while (text)\n    return defs;\n}\n\nexport { parseKeyDef };\n"],"mappings":"AAAA,OAAO,oCAAoC;AAC3C,OAAO,oCAAoC;AAC3C,OAAO,6BAA6B;AACpC,OAAO,4BAA4B;AACnC,OAAO,sCAAsC;AAC7C,SAASA,kBAAkB,QAAQ,uCAAuC;AAC1E,OAAO,wBAAwB;AAC/B,OAAO,eAAe;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAI,SAASC,WAAW,CAACC,WAAW,EAAEC,IAAI,EAAE;EACxC,MAAMC,IAAI,GAAG,EAAE;EACf,GAAG;IACC,MAAM;MAAEC,IAAI;MAAGC,UAAU;MAAGC,cAAc;MAAGC,eAAe;MAAGC,WAAW,GAAE,IAAI;MAAGC;IAAU,CAAC,GAAGV,kBAAkB,CAACG,IAAI,EAAE,UAAU,CAAC;IACrI,IAAIQ,GAAG;IACP,MAAMC,MAAM,GAAG,CAACD,GAAG,GAAGT,WAAW,CAACW,IAAI,CAAEC,GAAG,IAAG;MAC1C,IAAIT,IAAI,KAAK,GAAG,EAAE;QACd,IAAIM,GAAG;QACP,OAAO,CAAC,CAACA,GAAG,GAAGG,GAAG,CAACC,IAAI,MAAM,IAAI,IAAIJ,GAAG,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,GAAG,CAACK,WAAW,EAAE,MAAMV,UAAU,CAACU,WAAW,EAAE;MAClH,CAAC,MAAM,IAAIX,IAAI,KAAK,GAAG,EAAE;QACrB,IAAIY,IAAI;QACR,OAAO,CAAC,CAACA,IAAI,GAAGH,GAAG,CAACI,GAAG,MAAM,IAAI,IAAID,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACD,WAAW,EAAE,MAAMV,UAAU,CAACU,WAAW,EAAE;MACpH;MACA,OAAOF,GAAG,CAACI,GAAG,KAAKZ,UAAU;IACjC,CAAC,CAAC,MAAM,IAAI,IAAIK,GAAG,KAAK,KAAK,CAAC,GAAGA,GAAG,GAAG;MACnCO,GAAG,EAAE,SAAS;MACdH,IAAI,EAAE,SAAS;MACf,CAACV,IAAI,KAAK,GAAG,GAAG,MAAM,GAAG,KAAK,GAAGC;IACrC,CAAC;IACDF,IAAI,CAACe,IAAI,CAAC;MACNP,MAAM;MACNJ,eAAe;MACfC,WAAW;MACXC;IACJ,CAAC,CAAC;IACFP,IAAI,GAAGA,IAAI,CAACiB,KAAK,CAACb,cAAc,CAAC;EACrC,CAAC,QAAOJ,IAAI;EACZ,OAAOC,IAAI;AACf;AAEA,SAASH,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}