{"ast":null,"code":"import '../utils/click/isClickableInput.js';\nimport '../utils/dataTransfer/Clipboard.js';\nimport '../utils/edit/isEditable.js';\nimport '../utils/edit/maxLength.js';\nimport { getWindow } from '../utils/misc/getWindow.js';\nimport '../utils/keyDef/readNextDescriptor.js';\nimport '../utils/misc/level.js';\nimport '../options.js';\nimport { setUIValueClean, setUISelection, hasUISelection } from './UI.js';\nconst TrackChanges = Symbol('Track programmatic changes for React workaround');\n// When the input event happens in the browser, React executes all event handlers\n// and if they change state of a controlled value, nothing happens.\n// But when we trigger the event handlers in test environment with React@17,\n// the changes are rolled back before the state update is applied.\n// This results in a reset cursor.\n// There might be a better way to work around if we figure out\n// why the batched update is executed differently in our test environment.\nfunction isReact17Element(element) {\n  return Object.getOwnPropertyNames(element).some(k => k.startsWith('__react')) && getWindow(element).REACT_VERSION === 17;\n}\nfunction startTrackValue(element) {\n  if (!isReact17Element(element)) {\n    return;\n  }\n  element[TrackChanges] = {\n    previousValue: String(element.value),\n    tracked: []\n  };\n}\nfunction trackOrSetValue(element, v) {\n  var ref, ref1;\n  (ref = element[TrackChanges]) === null || ref === void 0 ? void 0 : (ref1 = ref.tracked) === null || ref1 === void 0 ? void 0 : ref1.push(v);\n  if (!element[TrackChanges]) {\n    setUIValueClean(element);\n    setUISelection(element, {\n      focusOffset: v.length\n    });\n  }\n}\nfunction commitValueAfterInput(element, cursorOffset) {\n  var ref;\n  const changes = element[TrackChanges];\n  element[TrackChanges] = undefined;\n  if (!(changes === null || changes === void 0 ? void 0 : (ref = changes.tracked) === null || ref === void 0 ? void 0 : ref.length)) {\n    return;\n  }\n  const isJustReactStateUpdate = changes.tracked.length === 2 && changes.tracked[0] === changes.previousValue && changes.tracked[1] === element.value;\n  if (!isJustReactStateUpdate) {\n    setUIValueClean(element);\n  }\n  if (hasUISelection(element)) {\n    setUISelection(element, {\n      focusOffset: isJustReactStateUpdate ? cursorOffset : element.value.length\n    });\n  }\n}\nexport { commitValueAfterInput, startTrackValue, trackOrSetValue };","map":{"version":3,"names":["getWindow","setUIValueClean","setUISelection","hasUISelection","TrackChanges","Symbol","isReact17Element","element","Object","getOwnPropertyNames","some","k","startsWith","REACT_VERSION","startTrackValue","previousValue","String","value","tracked","trackOrSetValue","v","ref","ref1","push","focusOffset","length","commitValueAfterInput","cursorOffset","changes","undefined","isJustReactStateUpdate"],"sources":["/Users/furusawakoutarou/Desktop/programming/React/react-guide-material/19_test/node_modules/@testing-library/user-event/dist/esm/document/trackValue.js"],"sourcesContent":["import '../utils/click/isClickableInput.js';\nimport '../utils/dataTransfer/Clipboard.js';\nimport '../utils/edit/isEditable.js';\nimport '../utils/edit/maxLength.js';\nimport { getWindow } from '../utils/misc/getWindow.js';\nimport '../utils/keyDef/readNextDescriptor.js';\nimport '../utils/misc/level.js';\nimport '../options.js';\nimport { setUIValueClean, setUISelection, hasUISelection } from './UI.js';\n\nconst TrackChanges = Symbol('Track programmatic changes for React workaround');\n// When the input event happens in the browser, React executes all event handlers\n// and if they change state of a controlled value, nothing happens.\n// But when we trigger the event handlers in test environment with React@17,\n// the changes are rolled back before the state update is applied.\n// This results in a reset cursor.\n// There might be a better way to work around if we figure out\n// why the batched update is executed differently in our test environment.\nfunction isReact17Element(element) {\n    return Object.getOwnPropertyNames(element).some((k)=>k.startsWith('__react')) && getWindow(element).REACT_VERSION === 17;\n}\nfunction startTrackValue(element) {\n    if (!isReact17Element(element)) {\n        return;\n    }\n    element[TrackChanges] = {\n        previousValue: String(element.value),\n        tracked: []\n    };\n}\nfunction trackOrSetValue(element, v) {\n    var ref, ref1;\n    (ref = element[TrackChanges]) === null || ref === void 0 ? void 0 : (ref1 = ref.tracked) === null || ref1 === void 0 ? void 0 : ref1.push(v);\n    if (!element[TrackChanges]) {\n        setUIValueClean(element);\n        setUISelection(element, {\n            focusOffset: v.length\n        });\n    }\n}\nfunction commitValueAfterInput(element, cursorOffset) {\n    var ref;\n    const changes = element[TrackChanges];\n    element[TrackChanges] = undefined;\n    if (!(changes === null || changes === void 0 ? void 0 : (ref = changes.tracked) === null || ref === void 0 ? void 0 : ref.length)) {\n        return;\n    }\n    const isJustReactStateUpdate = changes.tracked.length === 2 && changes.tracked[0] === changes.previousValue && changes.tracked[1] === element.value;\n    if (!isJustReactStateUpdate) {\n        setUIValueClean(element);\n    }\n    if (hasUISelection(element)) {\n        setUISelection(element, {\n            focusOffset: isJustReactStateUpdate ? cursorOffset : element.value.length\n        });\n    }\n}\n\nexport { commitValueAfterInput, startTrackValue, trackOrSetValue };\n"],"mappings":"AAAA,OAAO,oCAAoC;AAC3C,OAAO,oCAAoC;AAC3C,OAAO,6BAA6B;AACpC,OAAO,4BAA4B;AACnC,SAASA,SAAS,QAAQ,4BAA4B;AACtD,OAAO,uCAAuC;AAC9C,OAAO,wBAAwB;AAC/B,OAAO,eAAe;AACtB,SAASC,eAAe,EAAEC,cAAc,EAAEC,cAAc,QAAQ,SAAS;AAEzE,MAAMC,YAAY,GAAGC,MAAM,CAAC,iDAAiD,CAAC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,gBAAgB,CAACC,OAAO,EAAE;EAC/B,OAAOC,MAAM,CAACC,mBAAmB,CAACF,OAAO,CAAC,CAACG,IAAI,CAAEC,CAAC,IAAGA,CAAC,CAACC,UAAU,CAAC,SAAS,CAAC,CAAC,IAAIZ,SAAS,CAACO,OAAO,CAAC,CAACM,aAAa,KAAK,EAAE;AAC5H;AACA,SAASC,eAAe,CAACP,OAAO,EAAE;EAC9B,IAAI,CAACD,gBAAgB,CAACC,OAAO,CAAC,EAAE;IAC5B;EACJ;EACAA,OAAO,CAACH,YAAY,CAAC,GAAG;IACpBW,aAAa,EAAEC,MAAM,CAACT,OAAO,CAACU,KAAK,CAAC;IACpCC,OAAO,EAAE;EACb,CAAC;AACL;AACA,SAASC,eAAe,CAACZ,OAAO,EAAEa,CAAC,EAAE;EACjC,IAAIC,GAAG,EAAEC,IAAI;EACb,CAACD,GAAG,GAAGd,OAAO,CAACH,YAAY,CAAC,MAAM,IAAI,IAAIiB,GAAG,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,IAAI,GAAGD,GAAG,CAACH,OAAO,MAAM,IAAI,IAAII,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACC,IAAI,CAACH,CAAC,CAAC;EAC5I,IAAI,CAACb,OAAO,CAACH,YAAY,CAAC,EAAE;IACxBH,eAAe,CAACM,OAAO,CAAC;IACxBL,cAAc,CAACK,OAAO,EAAE;MACpBiB,WAAW,EAAEJ,CAAC,CAACK;IACnB,CAAC,CAAC;EACN;AACJ;AACA,SAASC,qBAAqB,CAACnB,OAAO,EAAEoB,YAAY,EAAE;EAClD,IAAIN,GAAG;EACP,MAAMO,OAAO,GAAGrB,OAAO,CAACH,YAAY,CAAC;EACrCG,OAAO,CAACH,YAAY,CAAC,GAAGyB,SAAS;EACjC,IAAI,EAAED,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACP,GAAG,GAAGO,OAAO,CAACV,OAAO,MAAM,IAAI,IAAIG,GAAG,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,GAAG,CAACI,MAAM,CAAC,EAAE;IAC/H;EACJ;EACA,MAAMK,sBAAsB,GAAGF,OAAO,CAACV,OAAO,CAACO,MAAM,KAAK,CAAC,IAAIG,OAAO,CAACV,OAAO,CAAC,CAAC,CAAC,KAAKU,OAAO,CAACb,aAAa,IAAIa,OAAO,CAACV,OAAO,CAAC,CAAC,CAAC,KAAKX,OAAO,CAACU,KAAK;EACnJ,IAAI,CAACa,sBAAsB,EAAE;IACzB7B,eAAe,CAACM,OAAO,CAAC;EAC5B;EACA,IAAIJ,cAAc,CAACI,OAAO,CAAC,EAAE;IACzBL,cAAc,CAACK,OAAO,EAAE;MACpBiB,WAAW,EAAEM,sBAAsB,GAAGH,YAAY,GAAGpB,OAAO,CAACU,KAAK,CAACQ;IACvE,CAAC,CAAC;EACN;AACJ;AAEA,SAASC,qBAAqB,EAAEZ,eAAe,EAAEK,eAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}