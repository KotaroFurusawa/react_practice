{"ast":null,"code":"import { Buttons } from './buttons.js';\nimport { Device } from './device.js';\nimport { Mouse } from './mouse.js';\nimport { Pointer } from './pointer.js';\nvar _registry, _k;\nclass PointerHost {\n  isKeyPressed(keyDef) {\n    return this.devices.get(keyDef.pointerType).isPressed(keyDef);\n  }\n  async press(instance, keyDef, position) {\n    const pointerName = this.getPointerName(keyDef);\n    const pointer = keyDef.pointerType === 'touch' ? this.pointers.new(pointerName, keyDef).init(instance, position) : this.pointers.get(pointerName);\n    // TODO: deprecate the following implicit setting of position\n    pointer.position = position;\n    if (pointer.pointerType !== 'touch') {\n      this.mouse.position = position;\n    }\n    this.devices.get(keyDef.pointerType).addPressed(keyDef);\n    this.buttons.down(keyDef);\n    pointer.down(instance, keyDef);\n    if (pointer.pointerType !== 'touch' && !pointer.isPrevented) {\n      this.mouse.down(instance, keyDef, pointer);\n    }\n  }\n  async move(instance, pointerName, position) {\n    const pointer = this.pointers.get(pointerName);\n    // In (some?) browsers this order of events can be observed.\n    // This interweaving of events is probably unnecessary.\n    // While the order of mouse (or pointer) events is defined per spec,\n    // the order in which they interweave/follow on a user interaction depends on the implementation.\n    const pointermove = pointer.move(instance, position);\n    const mousemove = pointer.pointerType === 'touch' || pointer.isPrevented && pointer.isDown ? undefined : this.mouse.move(instance, position);\n    pointermove === null || pointermove === void 0 ? void 0 : pointermove.leave();\n    mousemove === null || mousemove === void 0 ? void 0 : mousemove.leave();\n    pointermove === null || pointermove === void 0 ? void 0 : pointermove.enter();\n    mousemove === null || mousemove === void 0 ? void 0 : mousemove.enter();\n    pointermove === null || pointermove === void 0 ? void 0 : pointermove.move();\n    mousemove === null || mousemove === void 0 ? void 0 : mousemove.move();\n  }\n  async release(instance, keyDef, position) {\n    const device = this.devices.get(keyDef.pointerType);\n    device.removePressed(keyDef);\n    this.buttons.up(keyDef);\n    const pointer = this.pointers.get(this.getPointerName(keyDef));\n    // TODO: deprecate the following implicit setting of position\n    pointer.position = position;\n    if (pointer.pointerType !== 'touch') {\n      this.mouse.position = position;\n    }\n    if (device.countPressed === 0) {\n      pointer.up(instance, keyDef);\n    }\n    if (pointer.pointerType === 'touch') {\n      pointer.release(instance);\n    }\n    if (!pointer.isPrevented) {\n      if (pointer.pointerType === 'touch' && !pointer.isMultitouch) {\n        const mousemove = this.mouse.move(instance, pointer.position);\n        mousemove === null || mousemove === void 0 ? void 0 : mousemove.leave();\n        mousemove === null || mousemove === void 0 ? void 0 : mousemove.enter();\n        mousemove === null || mousemove === void 0 ? void 0 : mousemove.move();\n        this.mouse.down(instance, keyDef, pointer);\n      }\n      if (!pointer.isMultitouch) {\n        const mousemove1 = this.mouse.move(instance, pointer.position);\n        mousemove1 === null || mousemove1 === void 0 ? void 0 : mousemove1.leave();\n        mousemove1 === null || mousemove1 === void 0 ? void 0 : mousemove1.enter();\n        mousemove1 === null || mousemove1 === void 0 ? void 0 : mousemove1.move();\n        this.mouse.up(instance, keyDef, pointer);\n      }\n    }\n  }\n  getPointerName(keyDef) {\n    return keyDef.pointerType === 'touch' ? keyDef.name : keyDef.pointerType;\n  }\n  getPreviousPosition(pointerName) {\n    return this.pointers.has(pointerName) ? this.pointers.get(pointerName).position : undefined;\n  }\n  resetClickCount() {\n    this.mouse.resetClickCount();\n  }\n  getMouseTarget(instance) {\n    var _target;\n    return (_target = this.mouse.position.target) !== null && _target !== void 0 ? _target : instance.config.document.body;\n  }\n  setMousePosition(position) {\n    this.mouse.position = position;\n    this.pointers.get('mouse').position = position;\n  }\n  constructor(system) {\n    this.devices = new class {\n      get(k) {\n        var ref;\n        (ref = (_registry = this.registry)[_k = k]) !== null && ref !== void 0 ? ref : _registry[_k] = new Device();\n        return this.registry[k];\n      }\n      constructor() {\n        this.registry = {};\n      }\n    }();\n    this.pointers = new class {\n      new(pointerName, keyDef) {\n        const isPrimary = keyDef.pointerType !== 'touch' || !Object.values(this.registry).some(p => p.pointerType === 'touch' && !p.isCancelled);\n        if (!isPrimary) {\n          Object.values(this.registry).forEach(p => {\n            if (p.pointerType === keyDef.pointerType && !p.isCancelled) {\n              p.isMultitouch = true;\n            }\n          });\n        }\n        this.registry[pointerName] = new Pointer({\n          pointerId: this.nextId++,\n          pointerType: keyDef.pointerType,\n          isPrimary\n        });\n        return this.registry[pointerName];\n      }\n      get(pointerName) {\n        if (!this.has(pointerName)) {\n          throw new Error(`Trying to access pointer \"${pointerName}\" which does not exist.`);\n        }\n        return this.registry[pointerName];\n      }\n      has(pointerName) {\n        return pointerName in this.registry;\n      }\n      constructor() {\n        this.registry = {\n          mouse: new Pointer({\n            pointerId: 1,\n            pointerType: 'mouse',\n            isPrimary: true\n          })\n        };\n        this.nextId = 2;\n      }\n    }();\n    this.system = system;\n    this.buttons = new Buttons();\n    this.mouse = new Mouse();\n  }\n}\nexport { PointerHost };","map":{"version":3,"names":["Buttons","Device","Mouse","Pointer","_registry","_k","PointerHost","isKeyPressed","keyDef","devices","get","pointerType","isPressed","press","instance","position","pointerName","getPointerName","pointer","pointers","new","init","mouse","addPressed","buttons","down","isPrevented","move","pointermove","mousemove","isDown","undefined","leave","enter","release","device","removePressed","up","countPressed","isMultitouch","mousemove1","name","getPreviousPosition","has","resetClickCount","getMouseTarget","_target","target","config","document","body","setMousePosition","constructor","system","k","ref","registry","isPrimary","Object","values","some","p","isCancelled","forEach","pointerId","nextId","Error"],"sources":["/Users/furusawakoutarou/Desktop/programming/React/react-guide-material/19_test/node_modules/@testing-library/user-event/dist/esm/system/pointer/index.js"],"sourcesContent":["import { Buttons } from './buttons.js';\nimport { Device } from './device.js';\nimport { Mouse } from './mouse.js';\nimport { Pointer } from './pointer.js';\n\nvar _registry, _k;\nclass PointerHost {\n    isKeyPressed(keyDef) {\n        return this.devices.get(keyDef.pointerType).isPressed(keyDef);\n    }\n    async press(instance, keyDef, position) {\n        const pointerName = this.getPointerName(keyDef);\n        const pointer = keyDef.pointerType === 'touch' ? this.pointers.new(pointerName, keyDef).init(instance, position) : this.pointers.get(pointerName);\n        // TODO: deprecate the following implicit setting of position\n        pointer.position = position;\n        if (pointer.pointerType !== 'touch') {\n            this.mouse.position = position;\n        }\n        this.devices.get(keyDef.pointerType).addPressed(keyDef);\n        this.buttons.down(keyDef);\n        pointer.down(instance, keyDef);\n        if (pointer.pointerType !== 'touch' && !pointer.isPrevented) {\n            this.mouse.down(instance, keyDef, pointer);\n        }\n    }\n    async move(instance, pointerName, position) {\n        const pointer = this.pointers.get(pointerName);\n        // In (some?) browsers this order of events can be observed.\n        // This interweaving of events is probably unnecessary.\n        // While the order of mouse (or pointer) events is defined per spec,\n        // the order in which they interweave/follow on a user interaction depends on the implementation.\n        const pointermove = pointer.move(instance, position);\n        const mousemove = pointer.pointerType === 'touch' || pointer.isPrevented && pointer.isDown ? undefined : this.mouse.move(instance, position);\n        pointermove === null || pointermove === void 0 ? void 0 : pointermove.leave();\n        mousemove === null || mousemove === void 0 ? void 0 : mousemove.leave();\n        pointermove === null || pointermove === void 0 ? void 0 : pointermove.enter();\n        mousemove === null || mousemove === void 0 ? void 0 : mousemove.enter();\n        pointermove === null || pointermove === void 0 ? void 0 : pointermove.move();\n        mousemove === null || mousemove === void 0 ? void 0 : mousemove.move();\n    }\n    async release(instance, keyDef, position) {\n        const device = this.devices.get(keyDef.pointerType);\n        device.removePressed(keyDef);\n        this.buttons.up(keyDef);\n        const pointer = this.pointers.get(this.getPointerName(keyDef));\n        // TODO: deprecate the following implicit setting of position\n        pointer.position = position;\n        if (pointer.pointerType !== 'touch') {\n            this.mouse.position = position;\n        }\n        if (device.countPressed === 0) {\n            pointer.up(instance, keyDef);\n        }\n        if (pointer.pointerType === 'touch') {\n            pointer.release(instance);\n        }\n        if (!pointer.isPrevented) {\n            if (pointer.pointerType === 'touch' && !pointer.isMultitouch) {\n                const mousemove = this.mouse.move(instance, pointer.position);\n                mousemove === null || mousemove === void 0 ? void 0 : mousemove.leave();\n                mousemove === null || mousemove === void 0 ? void 0 : mousemove.enter();\n                mousemove === null || mousemove === void 0 ? void 0 : mousemove.move();\n                this.mouse.down(instance, keyDef, pointer);\n            }\n            if (!pointer.isMultitouch) {\n                const mousemove1 = this.mouse.move(instance, pointer.position);\n                mousemove1 === null || mousemove1 === void 0 ? void 0 : mousemove1.leave();\n                mousemove1 === null || mousemove1 === void 0 ? void 0 : mousemove1.enter();\n                mousemove1 === null || mousemove1 === void 0 ? void 0 : mousemove1.move();\n                this.mouse.up(instance, keyDef, pointer);\n            }\n        }\n    }\n    getPointerName(keyDef) {\n        return keyDef.pointerType === 'touch' ? keyDef.name : keyDef.pointerType;\n    }\n    getPreviousPosition(pointerName) {\n        return this.pointers.has(pointerName) ? this.pointers.get(pointerName).position : undefined;\n    }\n    resetClickCount() {\n        this.mouse.resetClickCount();\n    }\n    getMouseTarget(instance) {\n        var _target;\n        return (_target = this.mouse.position.target) !== null && _target !== void 0 ? _target : instance.config.document.body;\n    }\n    setMousePosition(position) {\n        this.mouse.position = position;\n        this.pointers.get('mouse').position = position;\n    }\n    constructor(system){\n        this.devices = new class {\n            get(k) {\n                var ref;\n                (ref = (_registry = this.registry)[_k = k]) !== null && ref !== void 0 ? ref : _registry[_k] = new Device();\n                return this.registry[k];\n            }\n            constructor(){\n                this.registry = {};\n            }\n        }();\n        this.pointers = new class {\n            new(pointerName, keyDef) {\n                const isPrimary = keyDef.pointerType !== 'touch' || !Object.values(this.registry).some((p)=>p.pointerType === 'touch' && !p.isCancelled);\n                if (!isPrimary) {\n                    Object.values(this.registry).forEach((p)=>{\n                        if (p.pointerType === keyDef.pointerType && !p.isCancelled) {\n                            p.isMultitouch = true;\n                        }\n                    });\n                }\n                this.registry[pointerName] = new Pointer({\n                    pointerId: this.nextId++,\n                    pointerType: keyDef.pointerType,\n                    isPrimary\n                });\n                return this.registry[pointerName];\n            }\n            get(pointerName) {\n                if (!this.has(pointerName)) {\n                    throw new Error(`Trying to access pointer \"${pointerName}\" which does not exist.`);\n                }\n                return this.registry[pointerName];\n            }\n            has(pointerName) {\n                return pointerName in this.registry;\n            }\n            constructor(){\n                this.registry = {\n                    mouse: new Pointer({\n                        pointerId: 1,\n                        pointerType: 'mouse',\n                        isPrimary: true\n                    })\n                };\n                this.nextId = 2;\n            }\n        }();\n        this.system = system;\n        this.buttons = new Buttons();\n        this.mouse = new Mouse();\n    }\n}\n\nexport { PointerHost };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}